package cduntonmod7csc222;

import java.text.*;

// note that this is an abstract class (see p455 of your text)
// I do not want any one to create a generic Insurance instance
// (we only sell Auto, Life, and Health) but so as not to repeat
// common fields in those , we move them up one hierarchy level
// and make a generic Insurance class

// implements the interface Comparable so I can define how to order
// or sort Insurance objects

/**
 * Insurance class used to describe an Insurance object
 * 
 * @author cdunt
 * 
 */

public abstract class Insurance implements Comparable<Insurance> {

	// NOTE: these fields are protected!!!!! If I am to inherit
	// these, they must be protected (private allows NO other classes
	// to use them) - protected means this class and any class that inherits
	// from this one can use these
	
	/**
	 * used to hold a Customer object
	 */
	protected Customer customer;
	
	/**
	 * used to hold yearly rate of the insurance
	 */
	protected double yearlyRate;
	
	/**
	 * a unique policy number generated by the program
	 */
	protected int policyNumber;
	
	/**
	 * used to format numbers as currency
	 */
	NumberFormat currency = NumberFormat.getCurrencyInstance();
	
	/**
	 * a static variable used to make policy numbers unique
	 */
	public static int num = 1000;
	
	/**
	 * Full Constructor - used to create a new insurance policy.
	 * Creates a unique policy number
	 * 
	 * @param cust - Customer object
	 */
	public Insurance(Customer cust) {
		customer = cust;
		policyNumber = num;
		num++;

	}
	
	/**
	 * Constructor used for reading from a file where a policy number and
	 * rate are already set
	 * @param Customer - Customer object
	 * @param int - policy number of an Insurance object
	 * @param double - yearly rate of an Insurance object
	 */
	public Insurance(Customer cust, int polNum, double yrRate) {
		customer = cust;
		policyNumber = polNum;
		yearlyRate = yrRate;

	}
	
	/**
	 * Empty constructor but still creates a unique policy number
	 */
	public Insurance() {
		policyNumber = num;
		num++;
	}

	// NOTE: this is an abstract class. That means it can not be used (has no body)
	// but by putting here, we require any class that inherits from the Insurance
	// class
	// to fully implement this method if they want to be a concrete class
	
	/**
	 * used to set the yearly rate for an Insurance object
	 */
	public abstract void calcRate();
	
	/**
	 * used to convert the object to a String output
	 */
	public String toString() {
		return (customer.toString() + " with policy number " + policyNumber + " has a yearly rate of "
				+ currency.format(yearlyRate));
	}
	/**
	 * used to print to a file
	 */
	public String toStringF() {
		return "";
		// this needs to return "FirstName|LastName|CustID|InsCost|PolicyNum"
//		return "|" + super.toStringF() + "|" + numCars;
	}


	// getters and setters
	
	/**
	 * used to get the Customer object
	 * @return a Customer object
	 */
	public Customer getCustomer() {
		return customer;
	}
	
	/**
	 * used to get the policy number from the Insurance object
	 * @return an int that is the policy number for the Insurance object
	 */
	public int getPolicyNumber() {
		return policyNumber;
	}
	/**
	 * used to get the yearly rate from the Insurance object
	 * @return a double that is the yearly rate for the Insurance object
	 */
	public double getYearlyRate() {
		return yearlyRate;
	}
	/**
	 * used to set a Customer object
	 * @param customer - Customer object
	 */
	public void setCustomer(Customer customer) {
		this.customer = customer;
	}
	/**
	 * used to set the policy number of the Insurance object
	 * @param int - policy number
	 */
	public void setPolicyNumber(int policyNumber) {
		this.policyNumber = policyNumber;
	}
	/**
	 * used to set the yearly rate of the Insurance object
	 * @param double - yearly rate
	 */
	public void setYearlyRate(double yearlyRate) {
		this.yearlyRate = yearlyRate;
	}

	// required by the Comparable interface
	// we want to compare policy numbers
	// Look at how we did the one in the Customer blueprint
	// Look at the one in the search_sort.Account class
	// Note the difference if you are sorting on primitives versus objects
	
	/**
	 * used to define how to compare two Insurance objects
	 */
	public int compareTo(Insurance ins) {
		if (this.policyNumber > ins.policyNumber) {
			return 1;
		} else if (this.policyNumber <ins.policyNumber) {
			return -1;
		} else
			return 0;
	}

}
